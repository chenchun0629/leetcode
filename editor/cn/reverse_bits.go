package main

import (
	"fmt"
	"strconv"
)

func main() {
	// 先分别取原数 10000110 11011000 的奇数位和偶数位，将空余位用 0 填充：
	// 00000010100101000001111010011100
	// 原数：  10000110 11011000
	// 奇数位： 10000010 10001000
	// 偶数位： 00000100 01010000

	// 再将奇数位右移一位，偶数位左移一位，此时将两个数据相或即可以达到奇偶位上数据交换的效果：
	// 原数：  10000110 11011000
	// 奇数位右移一位： 0 10000010 1000100
	// 偶数位左移一位：0000100 01010000 0
	// 两数相或得到： 01001001 11100100

	// 0x5 对应 二进制 0101
	// 1100 & 0101 = 0100 取偶位数
	fmt.Printf("%b \n", 0b1100&0x5)

	// OxA 对应 十进制 10 对应 二进制 1010
	// 1100 & 1010 = 1000 取奇位数
	fmt.Printf("%b \n", 0b1100&0xA)

	// 交换奇偶位， 偶位左移， 奇位右移
	// 0100 -> 0 1000
	// 1000 -> 0100 0
	fmt.Printf("%b \n", 0b1100&0x5<<1)
	fmt.Printf("%b \n", 0b1100&0xA>>1)
	// 两者合体 1000 | 0100 = 1100
	var num2 = (0b1100 & 0x5 << 1) | (0b1100 & 0xA >> 1)
	fmt.Printf("%b \n", num2)

	// 然后交换12/34位
	// 1100 对应 十六进制  0xC
	// 0011 对应 十六进制  0x3
	// 然后 12位右移两位， 34位左移两位 完成倒置
	num2 = (0b1100 & num2 << 2) | (0b1100 & num2 >> 2)
	fmt.Printf("%b \n", num2) // 0011

	// 更多位数
	// 首先 22一组 一一交换
	// ... 44一组 两两交换
	// ... 88一组 四四交换
	// ...

	//var num = 0b1010101001010101
	//// 1010101000000000
	//// 101010100000000
	//fmt.Printf("%b \n", (num&0xAAAA)) // 101010100000000
	//// 1010101
	//// 10101010
	//fmt.Printf("%b \n", (num&0x5555)) // 10101010
	//num = ((num & 0xAAAA) >> 1) | ((num & 0x5555) << 1)
	//fmt.Printf("%b \n", num)

	//fmt.Println(reverseBits(0b00000010100101000001111010011100))

}

//颠倒给定的 32 位无符号整数的二进制位。
//
// 提示：
//
//
// 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的
//还是无符号的，其内部的二进制表示形式都是相同的。
// 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
//
//
//
//
//
// 示例 1：
//
//
//输入：n = 00000010100101000001111010011100
//输出：964176192 (00111001011110000010100101000000)
//解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
//     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
//
// 示例 2：
//
//
//输入：n = 11111111111111111111111111111101
//输出：3221225471 (10111111111111111111111111111111)
//解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
//     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
//
//
//
// 提示：
//
//
// 输入是一个长度为 32 的二进制字符串
//
//
//
//
// 进阶: 如果多次调用这个函数，你将如何优化你的算法？
// Related Topics 位运算 分治 👍 459 👎 0

//leetcode submit region begin(Prohibit modification and deletion)
// reverseBits 方法B 通过位运算
func reverseBits(num uint32) uint32 {
	num = ((num & 0xAAAAAAAA) >> 1) | ((num & 0x55555555) << 1)
	num = ((num & 0xCCCCCCCC) >> 2) | ((num & 0x33333333) << 2)
	num = ((num & 0xF0F0F0F0) >> 4) | ((num & 0x0F0F0F0F) << 4)
	num = ((num & 0xFF00FF00) >> 8) | ((num & 0x00FF00FF) << 8)
	num = ((num & 0xFFFFFFFF) >> 16) | ((num & 0xFFFFFFFF) << 16)
	return num
}

//leetcode submit region end(Prohibit modification and deletion)

// reverseBits_A 方法A 转字符串首位交换
func reverseBits_A(num uint32) uint32 {
	//fmt.Println(fmt.Sprintf("%b", num), "================a")
	var s = []rune(fmt.Sprintf("%032s", fmt.Sprintf("%b", num)))
	var b, e = 0, len(s) - 1
	for b < e {
		s[b], s[e] = s[e], s[b]
		b++
		e--
	}

	var i, _ = strconv.ParseInt(string(s), 2, 64)
	//fmt.Println(string(s), i, err, "================b")
	return uint32(i)
}
